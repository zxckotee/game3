# Решение проблемы продажи предметов после перезахода в игру

## Проблема

После перезахода в игру возникает ситуация, когда во вкладке "Продажа" на рынке невозможно продать предмет, так как кнопка продажи заблокирована. Причина в том, что система не может найти соответствующего торговца для выбранного предмета.

## Анализ кода и причина проблемы

На основе анализа кода `MarketTab.js` и логов, можно определить следующее:

1. Данные о торговцах успешно загружаются при открытии вкладки рынка (строка 439)
2. Во вкладке "Товары" всё работает корректно
3. Во вкладке "Продажа" код пытается найти торговца для предмета, но поиск не срабатывает

Основная проблема в логике сопоставления предметов из инвентаря игрока с товарами торговцев:

```javascript
// Строки 1423-1429
const itemIdentifier = item.itemId || item.id;
console.log(`Ищем торговца для товара с ID: ${itemIdentifier}`);

// Ищем совпадение по item_id
const matchingMarketItem = market.marketItems.find(
  marketItem => marketItem.itemId === itemIdentifier
);
```

При анализе структуры данных выявлены следующие различия:

**В инвентаре игрока (player.inventory.items):**
```javascript
{
  id: "cloth_robe",       // Строковый ID
  name: "Льняная роба",
  type: "armor",          // Тип предмета
  quality: "common"       // Редкость
  // другие поля
}
```

**В списке товаров торговцев (market.marketItems):**
```javascript
{
  id: 444,                // Числовой ID (не совпадает с ID в инвентаре)
  itemId: "cloth_robe",   // Строковый ID (совпадает с id в инвентаре)
  itemType: "armor",      // Тип предмета (вместо type)
  rarity: "common"        // Редкость (вместо quality)
  // другие поля
}
```

Из-за этих различий прямое сопоставление `marketItem.itemId === itemIdentifier` не работает после перезахода в игру, поскольку неверно определяется идентификатор предмета.

## Решение

Предлагается модифицировать логику сопоставления предметов для обеспечения более гибкого поиска соответствия между предметом инвентаря и товарами торговцев. При этом новые запросы к API не требуются, мы будем работать с теми данными, которые уже загружены.

### 1. Модификация логики поиска соответствия предмета с товаром торговца

В файле `src/components/tabs/MarketTab.js` необходимо изменить логику сопоставления предметов при их выборе для продажи (строки около 1426-1429):

```javascript
// Вместо текущего прямого сопоставления
const matchingMarketItem = market.marketItems.find(
  marketItem => marketItem.itemId === itemIdentifier
);

// Реализовать более гибкое сопоставление с учетом точной структуры данных
const matchingMarketItem = market.marketItems.find(marketItem => {
  // Логирование для отладки
  console.log(`Сравниваем: Предмет игрока:`, {
    id: item.id,
    name: item.name,
    type: item.type,
    quality: item.quality
  }, `с товаром торговца:`, {
    id: marketItem.id,
    itemId: marketItem.itemId,
    name: marketItem.name,
    itemType: marketItem.itemType,
    rarity: marketItem.rarity
  });
  
  // Основное сопоставление: itemId торговца должен совпадать с id предмета инвентаря
  if (marketItem.itemId === item.id) return true;
  
  // Дополнительные проверки
  // Проверка по имени предмета как запасной вариант
  if (marketItem.name && item.name &&
      marketItem.name.toLowerCase() === item.name.toLowerCase()) {
    // Дополнительно проверяем совпадение типа и редкости
    if ((marketItem.itemType === item.type) &&
        (marketItem.rarity === item.quality)) {
      return true;
    }
  }
  
  return false;
});
```

### 2. Добавление подобной логики в функцию handleSellItem

Для дополнительной надежности аналогичную логику стоит добавить в начало функции `handleSellItem` (около строки 911), чтобы даже если торговец не был найден при выборе предмета, была дополнительная попытка найти его перед продажей:

```javascript
const handleSellItem = async () => {
  if (!selectedSellItem) return;
  
  // Если торговец не выбран, но есть данные рынка, пробуем найти подходящего
  if (!selectedMerchant && market?.marketItems?.length > 0) {
    console.log(`Попытка автоматического поиска торговца для товара:`, {
      id: selectedSellItem.id,
      name: selectedSellItem.name,
      type: selectedSellItem.type,
      quality: selectedSellItem.quality
    });
    
    // Используем гибкое сопоставление с учетом структуры данных
    const matchingMarketItem = market.marketItems.find(marketItem => {
      // Основное сопоставление: itemId торговца должен совпадать с id предмета инвентаря
      if (marketItem.itemId === selectedSellItem.id) return true;
      
      // Дополнительные проверки
      // Проверка по имени предмета как запасной вариант
      if (marketItem.name && selectedSellItem.name &&
          marketItem.name.toLowerCase() === selectedSellItem.name.toLowerCase()) {
        // Дополнительно проверяем совпадение типа и редкости
        if ((marketItem.itemType === selectedSellItem.type) &&
            (marketItem.rarity === selectedSellItem.quality)) {
          return true;
        }
      }
      
      return false;
    });
    
    // Выводим все доступные товары в консоль для отладки
    if (!matchingMarketItem) {
      console.log('Не найдено совпадение. Доступные товары:',
        market.marketItems.map(item => ({
          id: item.id,
          itemId: item.itemId,
          name: item.name,
          itemType: item.itemType,
          rarity: item.rarity
        }))
      );
    }
    
    if (matchingMarketItem && matchingMarketItem.sellerId) {
      const merchant = market.merchants?.find(m => m.id === matchingMarketItem.sellerId);
      if (merchant) {
        setSelectedMerchant({
          id: merchant.id,
          name: merchant.name
        });
        console.log(`Автоматически выбран торговец: ${merchant.name} (ID: ${merchant.id})`);
        // Небольшая задержка для обновления состояния
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  }
  
  // Проверка наличия выбранного торговца (существующий код)
  if (!selectedMerchant || !selectedMerchant.id) {
    alert("Этот предмет нельзя продать - подходящий торговец не найден");
    return;
  }
  
  // Остальная часть функции handleSellItem без изменений
  // ...
};
```

## Преимущества предложенного решения

1. **Без дополнительных запросов** - решение не требует дополнительных API-запросов, работает с уже загруженными данными
2. **Учет различий в структуре данных** - явно учитывает различия в именах полей между инвентарем игрока и товарами торговцев:
   - `id` в инвентаре соответствует `itemId` в товарах торговцев
   - `type` в инвентаре соответствует `itemType` в товарах торговцев
   - `quality` в инвентаре соответствует `rarity` в товарах торговцев
3. **Расширенное логирование** - детальное отображение структуры сравниваемых объектов для отладки
4. **Двойная проверка** - поиск торговца происходит как при выборе предмета, так и непосредственно перед продажей
5. **Запасной метод сопоставления** - если не удается сопоставить по ID, происходит попытка сопоставления по имени, типу и редкости предмета

## Шаги по внедрению

1. Сначала внести изменения в логику выбора предмета для продажи в `MarketTab.js` (около строки 1426)
2. Затем внести изменения в функцию `handleSellItem` (около строки 911)
3. Выполнить проверку изменений, наблюдая за выводимой в консоль отладочной информацией:
   - Проверить структуру объектов в инвентаре игрока и товаров торговцев
   - Убедиться, что при выборе предмета происходит корректное сопоставление
   - Убедиться, что функция продажи также находит соответствующего торговца

## Проверка работоспособности

После внедрения этих изменений рекомендуется проверить:
1. Переход между вкладками "Товары" и "Продажа"
2. Перезаход в игру и последующую продажу предметов
3. Работу с разными типами предметов для проверки надежности сопоставления
4. Логи в консоли для подтверждения корректности сопоставления предметов